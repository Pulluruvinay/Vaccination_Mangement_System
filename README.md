In place of one monolithic app, in microservice architecture we have several independent applications that can run on their own and may be created using different coding or programming languages.

This Microservices example using spring boot captures your business scenario, answering the question “What problem are you trying to solve?”

Microservice architectures are the ‘new normal’. Building small, self-contained, ready to run applications can bring great flexibility and added resilience to your code. Spring Boot’s many purpose-built features make it easy to build and run your microservices in production at scale. But no microservice architecture is complete without Spring Cloud ‒ easing administration and boosting your fault-tolerance.

Microservice resilience with Spring Cloud The distributed nature of microservices brings challenges. Spring helps you mitigate these. With several ready-to-run cloud patterns, Spring Cloud can help with service discovery, load-balancing, circuit-breaking, distributed tracing, and monitoring. It can even act as an API gateway.

With Spring Boot, your microservices architecture can start small and iterate fast. That’s why it has become the de facto standard for Java™ microservices. Quickstart your project with Spring Initializr and then package as a JAR. With Spring Boot’s embedded server model, you’re ready to go in minutes.

Need to Eureka: Netflix Eureka service registry - A service registry is useful because it enables client-side load-balancing and decouples service providers from consumers without the need for DNS. Then u can build a client that both registers itself with the registry and uses it to resolve its own host. Spring Cloud helps you manage that complexity with a service registry like Eureka and Consul and client-side load-balancing.

The service’s port is defaulted to the well-known 8761.
